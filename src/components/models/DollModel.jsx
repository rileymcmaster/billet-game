/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 /Users/rileymcmaster/Documents/Personal/Web/Debris/Scan/Oz/oz_4.glb --transform --simplify 
Files: /Users/rileymcmaster/Documents/Personal/Web/Debris/Scan/Oz/oz_4.glb [20.29MB] > /Users/rileymcmaster/Projects/Personal/threejs/ecctrl/oz_4-transformed.glb [568.8KB] (97%)
*/

import React, { useEffect, useRef, useState } from "react";
import { useFrame, useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import * as THREE from "three";
import { calculateFloat } from "../../helpers/mathHelper";

const src = "/assets/models/oz_4_2-transformed.glb";

const DollModel = ({ handleEnd, ...props }) => {
	const group = useRef();
	const skinMesh = useRef();

	const { scene, animations } = useGLTF(src, true);
	const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
	const { nodes, materials } = useGraph(clone);
	const { actions, mixer } = useAnimations(animations, group);

	useEffect(() => {
		const action = actions["uncross arms"];
		action.clampWhenFinished = true;
		action.reset().setLoop(THREE.LoopOnce).play().paused = true;

		return () => {
			action.fadeOut(0.5);
		};
	}, []);

	let spinRatioTally = 0;
	let scaleRatioTally = 0;

	useFrame(({ camera }) => {
		const isAtEnd = camera.position.z > 16;

		const { ratio: spinRatio, ratioMax: spinRatioMax } = calculateFloat({ start: 10, end: 14, value: camera.position.z });
		if (spinRatioMax >= 0 && spinRatioTally < spinRatioMax) {
			spinRatioTally = spinRatioMax;
		}
		if (spinRatioTally >= 0) {
			group.current.rotation.x = THREE.MathUtils.damp(group.current.rotation.x, (-spinRatioTally * Math.PI * 1.5) / 8, 0.5, 0.5);
			group.current.rotation.y = THREE.MathUtils.damp(group.current.rotation.y, spinRatioTally * Math.PI, 0.05, 2);
		}

		const { ratio: scaleRatio, ratioMax: scaleRatioMax } = calculateFloat({ start: 12, end: 15, value: camera.position.z });
		if (scaleRatioMax >= 0 && scaleRatioTally < scaleRatioMax) {
			scaleRatioTally = scaleRatioMax;
		}

		if (scaleRatioMax >= 0) {
			group.current.scale.x = THREE.MathUtils.damp(group.current.scale.x, scaleRatioTally / 2 + 4, 2, 0.5);
			group.current.scale.y = THREE.MathUtils.damp(group.current.scale.y, scaleRatioTally / 2 + 4, 2, 0.5);
			group.current.scale.z = THREE.MathUtils.damp(group.current.scale.z, scaleRatioTally / 2 + 4, 2, 0.5);
			group.current.position.y = THREE.MathUtils.damp(group.current.position.y, spinRatioTally * 1 - 2.5, 0.001, 0.5);
		}

		if (isAtEnd && actions["uncross arms"].paused == true) {
			actions["uncross arms"].paused = false;
		}
	});

	return (
		<group ref={group} {...props} dispose={null} position={[0, -1, 27]} scale={4}>
			<group name="Scene">
				<group name="metarig">
					<primitive object={nodes.spine} />
				</group>
				<skinnedMesh receiveShadow ref={skinMesh} name="Oz_hi003" geometry={nodes.Oz_hi003.geometry} material={materials["Material_0.006"]} skeleton={nodes.Oz_hi003.skeleton}></skinnedMesh>
			</group>
		</group>
	);
};

export default DollModel;
// useGLTF.preload(src);
