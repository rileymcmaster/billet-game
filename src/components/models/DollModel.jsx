/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 /Users/rileymcmaster/Documents/Personal/Web/Debris/Scan/Oz/oz_4.glb --transform --simplify 
Files: /Users/rileymcmaster/Documents/Personal/Web/Debris/Scan/Oz/oz_4.glb [20.29MB] > /Users/rileymcmaster/Projects/Personal/threejs/ecctrl/oz_4-transformed.glb [568.8KB] (97%)
*/

import React, { useContext, useEffect, useRef, useState } from "react";
import { useFrame, useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations, useCursor } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import * as THREE from "three";
import { calculateFloat } from "../../helpers/mathHelper";
import AppContext from "../../context/AppContext";
import ClickTarget from "../ClickTarget";

const DollModel = (props) => {
	const [clickable, setClickable] = useState(false);
	const group = useRef();
	const skinMesh = useRef();

	const { scene, animations } = useGLTF("/oz_4_2-transformed.glb");
	const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
	const { nodes, materials } = useGraph(clone);
	const { actions, mixer } = useAnimations(animations, group);

	useEffect(() => {
		const action = actions["uncross arms"];
		action.reset().setLoop(THREE.LoopOnce).play().paused = true;
		action.clampWhenFinished = true;

		mixer.addEventListener("finished", () => {
			setClickable(true);
		});
		return () => action.fadeOut(0.5);
	}, []);

	let spinRatioTally = 0;
	let scaleRatioTally = 0;

	useFrame(({ camera }) => {
		const isAtEnd = camera.position.z > 18;

		const { ratio: spinRatio, ratioMax: spinRatioMax } = calculateFloat({ start: 12, end: 16, value: camera.position.z });
		if (spinRatioMax >= 0 && spinRatioTally < spinRatioMax) {
			spinRatioTally = spinRatioMax;
		}
		if (spinRatioTally >= 0) {
			group.current.rotation.x = THREE.MathUtils.damp(group.current.rotation.x, (-spinRatioTally * Math.PI) / 8, 0.1, 0.5);
			group.current.rotation.y = THREE.MathUtils.damp(group.current.rotation.y, spinRatioTally * Math.PI, 0.5, 0.01);
		}

		const { ratio: scaleRatio, ratioMax: scaleRatioMax } = calculateFloat({ start: 14, end: 18, value: camera.position.z });
		if (scaleRatioMax >= 0 && scaleRatioTally < scaleRatioMax) {
			scaleRatioTally = scaleRatioMax;
		}

		if (scaleRatioMax >= 0) {
			group.current.scale.x = THREE.MathUtils.damp(group.current.scale.x, scaleRatioTally / 2 + 4, 5, 0.5);
			group.current.scale.y = THREE.MathUtils.damp(group.current.scale.y, scaleRatioTally / 2 + 4, 5, 0.5);
			group.current.scale.z = THREE.MathUtils.damp(group.current.scale.z, scaleRatioTally / 2 + 4, 5, 0.5);
			group.current.position.y = THREE.MathUtils.damp(group.current.position.y, spinRatioTally * 1 - 2.5, 0.001, 5);
		}

		if (isAtEnd && actions["uncross arms"].paused) {
			actions["uncross arms"].paused = false;
		}
	});

	return (
		<group ref={group} {...props} dispose={null} position={[0, -1, 27]} scale={4}>
			<group name="Scene">
				<group name="metarig">
					<primitive object={nodes.spine} />
				</group>
				<skinnedMesh receiveShadow ref={skinMesh} name="Oz_hi003" geometry={nodes.Oz_hi003.geometry} material={materials["Material_0.006"]} skeleton={nodes.Oz_hi003.skeleton}></skinnedMesh>
			</group>
			{clickable && <ClickTarget position={[0, 1.5, 0]} />}
		</group>
	);
};

export default DollModel;
useGLTF.preload("/oz_4_2-transformed.glb");
